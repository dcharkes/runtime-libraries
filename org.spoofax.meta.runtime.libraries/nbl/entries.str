module nbl/entries

imports
  
  nbl/collect
  nbl/utils
  nbl/uri
  task/core
  
signature

  constructors
    
    Def   : URI            -> Key
    Alias : URI            -> Key
    Use   : URI            -> Key
    Prop  : URI * Property -> Key
  
rules
  
  new-def(|partition, uri):
    x -> def-key
    with
      def-key := Def(uri);
      def-val := <force-origins(!uri)> x;
      task-add-solved-task(|partition, def-key, def-val);
			<new-alias(|partition, <nabl-nonunique-uri> uri, uri)> x
      
  new-alias(|partition, uri, alias-uri):
    x -> alias-key
    with
      alias-key := Alias(uri);
      alias-val := <force-origins(!alias-uri)> x;
      if <not(eq)> (uri, alias-uri) then
      	task-add-solved-task(|partition, alias-key, alias-val)
      end
      
  new-use(|partition, uri):
    x -> use-key
    with
      use-key := Use(uri);
      use-val := <force-origins(!uri)> x;
      task-add-solved-task(|partition, use-key, use-val)

  new-prop(|partition, uri, kind, val):
    x -> prop-key
    with
      prop-key := Prop(uri, kind);
      prop-val := <force-origins(!val)> x;
      task-add-solved-task(|partition, prop-key, prop-val)
      
rules // index uri & value projections
  
  /** @internal */
  nabl-uri-impl:
    Def(uri) -> uri
    
  /** @internal */
  nabl-uri-impl:
    Alias(uri) -> uri
    
  /** @internal */  
  nabl-uri-impl:
    Use(uri) -> <nabl-is-uri> uri
    
  /** @internal */  
  nabl-uri-impl:
    Prop(uri, _, _) -> uri
    
  /** @internal */  
  nabl-uri-impl:
    Prop(uri, _) -> uri
    
    
  /** @internal */
  nabl-value-impl:
    Def(value) -> value
    
  /** @internal */
  nabl-value-impl:
    Alias(value) -> value

  /** @internal */
  nabl-value-impl:
    Use(value) -> value
    
  /** @internal */
  nabl-value-impl:
    Prop(_, _, value) -> value

  /** @internal */  
  nabl-value-impl:
    Prop(value, _) -> value
