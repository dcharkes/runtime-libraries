module nbl/tasks

imports 
  
  task/core
  nbl/lookup
  nbl/collect
  nbl/query
  nbl/interface
  nbl/uri
  nbl/utils
  nbl/entries
  
signature
  
  constructors
    
    Resolve        : Scope * Namespace * Name    -> Instruction
    ResolveImport  : Scope * Namespace * Name    -> Instruction
    PropConstraint : List(Prop) * List(Result)   -> Instruction
    PropCalc       : Property * Term             -> Instruction
        
rules // Resolve definition
  
  perform-task(|nr):
  	Resolve(scope, ns, name) -> result
  	where
  		uri  := <nabl-uri> scope;
  		def* := <nabl-lookup-uri(|ns, name)> uri;
  		<nabl-extend-uri(|ns, name, ()); task-add-read(|nr)> uri;
  		switch !def*
        case ?[]:
        	fail
        otherwise: 
        	!def*
			end => result

rules // Resolve imported definition

	perform-task(|nr):
		ResolveImport(scope, ns, name) -> result
		where
			uri := <nabl-uri> scope;
			import* := <nabl-lookup-import-uri(|ns, name)> uri;
			<try(nabl-replace-uri-qualifier(|())); task-add-read(|nr)> uri;
      if <task-has-dependencies> import* then
      	result := <task-collect-dependencies> import*
      else
	      def* := <nabl-lookup(|ns, name)> import*;
	      <map(nabl-uri; nabl-extend-uri(|ns, name, ()); task-add-read(|nr))> import*;
	  		switch !def*
	        case ?[]:
	        	fail
	        otherwise:
	        	!def*
				end => result
      end
	  
rules // Property constraint
	  
  perform-task(|nr):
  	PropConstraint(prop*, res*) -> result
  	where
  		filtered := <concat; filter(nabl-resolve-constraint(|prop*))> res*;
      switch !filtered
      	case task-collect-dependencies => d: !d
      	otherwise: !filtered
      end => result
  		
  nabl-resolve-constraint(|prop*):
    entry -> entry'
    where
      filtered := <filter(nabl-resolve-constraint-one(|entry))> prop*;
      switch !filtered
      	case ?[]: fail
      	case task-collect-dependencies => d: !d
      	otherwise: !entry
      end => entry'
      
  nabl-resolve-constraint-one(|entry):
    Prop(type, expectedValue) -> entry'
    where
    	uri   := <nabl-uri> entry;
      value := <nabl-get-property(|type)> uri;
      if value' := <insert-results> value then
        expectedValue' := <insert-results> expectedValue;
        <eq> (expectedValue', value');
        entry' := entry
      else
        entry' := <task-create-dependencies> value
      end

rules // Property calculation

  perform-task(|nr): 
  	PropCalc(prop, term) -> result'
  	where
  		result := <calc-property> (prop, term);
  		switch !result
  			case task-collect-dependencies => d : !d
      	otherwise                           : id
			end => result'
