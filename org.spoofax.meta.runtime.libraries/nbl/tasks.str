module nbl/tasks

imports 
  
  task/core
  nbl/lookup
  nbl/collect
  nbl/query
  nbl/interface
  nbl/uri
  nbl/utils
  nbl/entries
  
signature
  
  constructors
    
    ResolveDefs            : Scope * Namespace * Name                  -> Instruction
    DisambiguateDefs       : List(Def) * List(Prop) * Namespace * Name -> Instruction
    ResolveNamedImports    : Scope * Namespace * Name                  -> Instruction
    ResolveWildcardImports : Scope * Namespace                         -> Instruction
    PropConstraint         : List(Prop) * List(Result)                 -> Instruction
    PropCalc               : Property * Term                           -> Instruction
        
rules // Resolve
  
  // Looks up defintions in scopes with namespace and name.
  perform-task(|nr):
  	ResolveDefs(scope*@<with(is-list|"Expected a list of scopes.")>, ns, name) -> result
  	where
  		uri*  := <filter(nabl-uri)> scope*;
  		name' := <try-remove-list; strip-annos> name; // Name could be a list, and annotated.
  		def*  := <nabl-lookup(|ns, name')> uri*;
  		<map(nabl-extend-uri(|ns, name', ()); task-add-read(|nr))> uri*;
  		switch !def*
        case ?[]:
        	fail
        otherwise: 
        	!def* // TODO: id?
			end => result

	// Calls a user-defined disambiguation filter on definitions with relevant information.
	perform-task(|nr):
		DisambiguateDefs(def*, prop*, namespace, name) -> result
		where
			if <Tl> def* then
				result := <try(nabl-disambiguate(|prop*, namespace, name))> def*
			else
				result := def*
			end

	// Looks up named imports, active in scopes with namespace and name..
	perform-task(|nr):
		ResolveNamedImports(scope*@<with(is-list|"Expected a list of scopes.")>, ns, name) -> result
		where
			uri*    := <filter(nabl-uri)> scope*;
			name'   := <try-remove-list; strip-annos> name; // Name could be a list, and annotated.
			import* := <nabl-lookup-named-import(|ns, name')> uri*;
			<map(try(nabl-replace-uri-qualifier(|())); task-add-read(|nr))> uri*;
      if <task-has-dependencies> import* then
      	result := <task-collect-dependencies> import*
      else
	      result := import*
      end
	
	// Looks up wildcard imports for a namespace active in scopes.
	perform-task(|nr):
		ResolveWildcardImports(scope*@<with(is-list|"Expected a list of scopes.")>, ns) -> result
		where
			uri*    := <filter(nabl-uri)> scope*;
			import* := <nabl-lookup-unnamed-import(|ns)> uri*;
			<map(try(nabl-replace-uri-qualifier(|())); task-add-read(|nr))> uri*;
      if <task-has-dependencies> import* then
      	result := <task-collect-dependencies> import*
      else
	      result := import*
      end

rules // Property constraints
	  
  perform-task(|nr):
  	PropConstraint(prop*, res*) -> result
  	where
  		filtered := <filter(nabl-resolve-constraint(|prop*))> res*;
      switch !filtered
      	case task-collect-dependencies => d: !d
      	otherwise: !filtered // TODO: id?
      end => result
  		
  nabl-resolve-constraint(|prop*):
    entry -> entry'
    where
      filtered := <filter(nabl-resolve-constraint-one(|entry))> prop*;
      switch !filtered
      	case ?[]: fail
      	case task-collect-dependencies => d: !d
      	otherwise: !entry
      end => entry'
      
  // TODO: check dependencies (3rd subterm) as well.
  nabl-resolve-constraint-one(|entry):
    Prop(type, expectedValue, _) -> entry'
    where
    	uri   := <nabl-uri> entry;
      value := <nabl-get-property(|type)> uri;
      if value' := <insert-results> value then
        expectedValue' := <insert-results> expectedValue;
        <nabl-property-eq(|type) <+ eq> (expectedValue', value');
        entry' := entry
      else
        entry' := <task-create-dependencies> value
      end

rules // Property calcuation

  perform-task(|nr): 
  	PropCalc(prop, term) -> result'
  	where
  		result := <calc-property> (prop, term);
  		switch !result
  			case task-collect-dependencies => d : !d
      	case not(is-list)                   : ![result]
      	otherwise                           : !result
			end => result'
